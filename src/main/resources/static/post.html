<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å¸–å­è¯¦æƒ…</title>
    <!-- å¼•å…¥ Vue.js å’Œ Axios.js -->
    <script src="https://unpkg.com/vue@2/dist/vue.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <link rel="stylesheet" href="css/post.css">
</head>
<body>

<div id="app" class="post-layout">
    <!-- LEFT COLUMN: IMAGE -->
    <div class="left-column">
        <div v-if="isLoading.image">æ­£åœ¨åŠ è½½å›¾ç‰‡...</div>
        <img v-else-if="post.imgPath" :src="postImageSrc" :alt="post.title" id="post-image">
        <div v-else>æš‚æ— å›¾ç‰‡</div>
    </div>

    <!-- RIGHT COLUMN: CONTENT & COMMENTS -->
    <div class="right-column">
        <!-- Overall Loading/Error for the right column -->
        <div v-if="isLoading.details" class="loading-indicator">æ­£åœ¨åŠ è½½å¸–å­è¯¦æƒ…...</div>
        <div v-else-if="error" class="error-message">{{ error }}</div>

        <!-- Container for post details (v-else ensures it only shows after loading and no error) -->
        <div v-else id="post-details">
            <div class="post-info">
                <h1>{{ post.title }}</h1>
                <div class="post-meta">
                    <span>ğŸ‘¤ ä½œè€…: {{ post.username || `ID: ${post.userId}` }}</span>
                    <span>ğŸ•’ å‘å¸ƒäº: {{ formattedCreateTime }}</span>
                    <span>ğŸ‘ï¸ æµè§ˆ: {{ post.viewCount }}</span>
                </div>
                <div class="post-body" v-html="post.content"></div>
            </div>

            <!-- Container for comments -->
            <div class="comments-section">
                <h2>è¯„è®ºåŒº ({{ comments.length }})</h2>
                <div id="comments-list">
                    <div v-if="isLoading.comments">æ­£åœ¨åŠ è½½è¯„è®º...</div>
                    <p v-else-if="comments.length === 0">è¿˜æ²¡æœ‰è¯„è®ºï¼Œå¿«æ¥æŠ¢å æ²™å‘å§ï¼</p>
                    <div v-else>
                        <div v-for="comment in comments" :key="comment.commentId" class="comment-item">
                            <div class="comment-author">ç”¨æˆ·: {{ comment.authorUsername || `ID: ${comment.authorId}` }}</div>
                            <div class="comment-content">{{ comment.content }}</div>
                            <div class="comment-time">{{ formatDateTime(comment.createTime) }}</div>
                        </div>
                    </div>
                </div>

                <!-- Form for new comments -->
                <form @submit.prevent="handleCommentSubmit" id="comment-form">
                    <h3>å‘è¡¨è¯„è®º</h3>
                    <textarea
                            v-model="newComment.content"
                            :disabled="!currentUser"
                            required
                            :placeholder="commentPlaceholder"
                    ></textarea>
                    <button type="submit" :disabled="isSubmitting || !currentUser">
                        {{ isSubmitting ? 'å‘å¸ƒä¸­...' : 'å‘å¸ƒ' }}
                    </button>
                    <p v-if="commentStatus" :class="['status', commentStatus.type]">{{ commentStatus.message }}</p>
                </form>
            </div>
        </div>
    </div>
</div>

<script>
    // --- Axios å…¨å±€é…ç½® ---
    axios.defaults.baseURL = 'http://localhost:8080';
    axios.defaults.withCredentials = true;
    axios.interceptors.request.use(
        config => {
            const token = localStorage.getItem('token');
            if (token) {
                config.headers.Authorization = `Bearer ${token}`;
            }
            return config;
        },
        error => Promise.reject(error)
    );

    new Vue({
        el: '#app',
        data: {
            postId: null,
            post: {},
            comments: [],
            currentUser: null,
            newComment: {
                content: '',
            },
            isLoading: {
                details: true,
                image: true,
                comments: true,
            },
            isSubmitting: false,
            error: null,
            commentStatus: null, // { message: '...', type: 'success' | 'error' }
        },
        computed: {
            postImageSrc() {
                return this.post.imgPath ? `${this.post.imgPath}` : '';
            },
            formattedCreateTime() {
                return this.formatDateTime(this.post.createTime);
            },
            commentPlaceholder() {
                return this.currentUser ? 'è¯·ç•™ä¸‹ä½ çš„è¯„è®º...' : 'è¯·å…ˆç™»å½•æ‰èƒ½å‘è¡¨è¯„è®º';
            }
        },
        methods: {
            formatDateTime(dateTimeString) {
                if (!dateTimeString) return 'æœªçŸ¥æ—¶é—´';
                return new Date(dateTimeString).toLocaleString('zh-CN', { hour12: false }).replace(/\//g, '-');
            },

            async fetchCurrentUser() {
                try {
                    const response = await axios.get('/user/info');
                    this.currentUser = response.data.data;
                } catch (error) {
                    console.warn('è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯å¤±è´¥ï¼Œå°†æ— æ³•å‘è¡¨è¯„è®ºã€‚', error.message);
                }
            },

            async fetchPostDetails() {
                try {
                    const response = await axios.get('/post/select', { params: { id: this.postId } });
                    console.log(response.data);
                    const postDataArray = response.data.data;

                    if (!postDataArray || postDataArray.length === 0) {
                        throw new Error('æœªæ‰¾åˆ°è¯¥å¸–å­æˆ–å¸–å­æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
                    }

                    const postObject = postDataArray[0];
                    console.log(response.data.data);

                    // ç°åœ¨åŸºäºæ­£ç¡®çš„ postObject è¿›è¡Œåˆ¤æ–­
                    if (!postObject || !postObject.postId) {
                        throw new Error('å¸–å­æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
                    }

                    this.post = postObject;
                } catch (error) {
                    console.error('åŠ è½½å¸–å­è¯¦æƒ…å¤±è´¥:', error);
                    this.error = `åŠ è½½å¸–å­è¯¦æƒ…å¤±è´¥: ${error.message}`;
                } finally {
                    this.isLoading.details = false;
                    this.isLoading.image = false;
                }
            },



            async fetchAndRenderComments() {
                this.isLoading.comments = true;
                try {
                    const response = await axios.get('/comment/get', { params: { postId: this.postId } });
                    // å‡è®¾è¯„è®ºæ•°æ®åœ¨ response.data.data
                    this.comments = response.data.data || [];
                } catch (error) {
                    console.error('åŠ è½½è¯„è®ºå¤±è´¥:', error);
                } finally {
                    this.isLoading.comments = false;
                }
            },

            async handleCommentSubmit() {
                if (!this.newComment.content.trim()) {
                    this.commentStatus = { message: 'è¯„è®ºå†…å®¹ä¸èƒ½ä¸ºç©ºï¼', type: 'error' };
                    return;
                }
                if (!this.currentUser) {
                    this.commentStatus = { message: 'è¯·å…ˆç™»å½•ï¼', type: 'error' };
                    return;
                }

                this.isSubmitting = true;
                this.commentStatus = { message: 'æ­£åœ¨å‘å¸ƒ...', type: 'info' };

                try {
                    const payload = {
                        content: this.newComment.content,
                        authorId: this.currentUser.userId, // ä»å·²è·å–çš„ç”¨æˆ·ä¿¡æ¯ä¸­å–ID
                        postId: this.postId,
                    };
                    await axios.post('/comment/add', payload);

                    this.commentStatus = { message: 'å‘å¸ƒæˆåŠŸï¼', type: 'success' };
                    this.newComment.content = '';
                    await this.fetchAndRenderComments();

                } catch (error) {
                    const errorMessage = error.response?.data?.message || error.message;
                    this.commentStatus = { message: `å‘å¸ƒå¤±è´¥: ${errorMessage}`, type: 'error' };
                } finally {
                    this.isSubmitting = false;
                }
            },

            async initializePage() {
                const urlParams = new URLSearchParams(window.location.search);
                this.postId = urlParams.get('id');

                if (!this.postId) {
                    this.error = 'é”™è¯¯ï¼šURLä¸­æœªæä¾›å¸–å­IDã€‚';
                    this.isLoading.details = false;
                    this.isLoading.image = false;
                    this.isLoading.comments = false;
                    return;
                }

                await Promise.all([
                    this.fetchCurrentUser(),
                    this.fetchPostDetails(),
                    this.fetchAndRenderComments(),
                ]);
            },
        },
        created() {
            this.initializePage();
        }
    });
</script>

</body>
</html>